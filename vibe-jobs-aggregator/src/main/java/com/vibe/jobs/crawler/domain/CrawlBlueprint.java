package com.vibe.jobs.crawler.domain;

import java.time.Instant;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

/**
 * Aggregate root that describes how a specific career site should be crawled.
 */
public class CrawlBlueprint {

    private final String code;
    private final String name;
    private final boolean enabled;
    private final int concurrencyLimit;
    private final String entryUrl;
    private final PagingStrategy pagingStrategy;
    private final CrawlFlow flow;
    private final ParserProfile parserProfile;
    private final RateLimit rateLimit;
    private final Map<String, Object> metadata;
    private final AutomationSettings automation;
    private final CrawlerBlueprintStatus status;
    private final String draftConfigJson;
    private final String lastTestReportJson;
    private final boolean autoGenerated;
    private final String generatedBy;
    private final Instant generatedAt;

    public CrawlBlueprint(String code,
                          String name,
                          boolean enabled,
                          int concurrencyLimit,
                          String entryUrl,
                          PagingStrategy pagingStrategy,
                          CrawlFlow flow,
                          ParserProfile parserProfile,
                          RateLimit rateLimit,
                          Map<String, Object> metadata,
                          AutomationSettings automation) {
        this(code,
                name,
                enabled,
                concurrencyLimit,
                entryUrl,
                pagingStrategy,
                flow,
                parserProfile,
                rateLimit,
                metadata,
                automation,
                CrawlerBlueprintStatus.ACTIVE,
                null,
                null,
                false,
                null,
                null);
    }

    public CrawlBlueprint(String code,
                          String name,
                          boolean enabled,
                          int concurrencyLimit,
                          String entryUrl,
                          PagingStrategy pagingStrategy,
                          CrawlFlow flow,
                          ParserProfile parserProfile,
                          RateLimit rateLimit,
                          Map<String, Object> metadata,
                          AutomationSettings automation,
                          CrawlerBlueprintStatus status,
                          String draftConfigJson,
                          String lastTestReportJson,
                          boolean autoGenerated,
                          String generatedBy,
                          Instant generatedAt) {
        this.code = sanitize(code);
        this.name = sanitize(name);
        this.enabled = enabled;
        this.concurrencyLimit = concurrencyLimit <= 0 ? 1 : concurrencyLimit;
        this.entryUrl = sanitize(entryUrl);
        this.pagingStrategy = pagingStrategy == null ? PagingStrategy.disabled() : pagingStrategy;
        this.flow = flow == null ? CrawlFlow.empty() : flow;
        this.parserProfile = parserProfile == null ? ParserProfile.empty() : parserProfile;
        this.rateLimit = rateLimit == null ? RateLimit.unlimited() : rateLimit;
        this.metadata = metadata == null ? Map.of() : Collections.unmodifiableMap(metadata);
        this.automation = automation == null ? AutomationSettings.disabled() : automation;
        this.status = status == null ? CrawlerBlueprintStatus.ACTIVE : status;
        this.draftConfigJson = draftConfigJson == null ? "" : draftConfigJson;
        this.lastTestReportJson = lastTestReportJson == null ? "" : lastTestReportJson;
        this.autoGenerated = autoGenerated;
        this.generatedBy = generatedBy == null ? "" : generatedBy.trim();
        this.generatedAt = generatedAt;
    }

    private String sanitize(String value) {
        return value == null ? "" : value.trim();
    }

    public String code() {
        return code;
    }

    public String name() {
        return name;
    }

    public boolean enabled() {
        return enabled;
    }

    public int concurrencyLimit() {
        return concurrencyLimit;
    }

    public String entryUrl() {
        return entryUrl;
    }

    public PagingStrategy pagingStrategy() {
        return pagingStrategy;
    }

    public CrawlFlow flow() {
        return flow;
    }

    public ParserProfile parserProfile() {
        return parserProfile;
    }

    public RateLimit rateLimit() {
        return rateLimit;
    }

    public Map<String, Object> metadata() {
        return metadata;
    }

    public AutomationSettings automation() {
        return automation;
    }

    public CrawlerBlueprintStatus status() {
        return status;
    }

    public String draftConfigJson() {
        return draftConfigJson;
    }

    public String lastTestReportJson() {
        return lastTestReportJson;
    }

    public boolean autoGenerated() {
        return autoGenerated;
    }

    public String generatedBy() {
        return generatedBy;
    }

    public Optional<Instant> generatedAt() {
        return Optional.ofNullable(generatedAt);
    }

    public boolean isConfigured() {
        return !entryUrl.isBlank() && parserProfile.isConfigured();
    }

    public String resolveEntryUrl(CrawlContext context, CrawlPagination pagination) {
        Objects.requireNonNull(context, "context");
        Objects.requireNonNull(pagination, "pagination");
        String base = context.entryUrlOverride().filter(url -> !url.isBlank()).orElse(entryUrl);
        if (base == null || base.isBlank()) {
            return "";
        }
        return pagingStrategy.apply(base, pagination);
    }

    public boolean allowsParallelism() {
        return concurrencyLimit > 1;
    }

    public Optional<Object> metadata(String key) {
        if (key == null || key.isBlank()) {
            return Optional.empty();
        }
        return Optional.ofNullable(metadata.get(key));
    }

    public boolean requiresBrowser() {
        if (!flow.isEmpty()) {
            for (CrawlStep step : flow.steps()) {
                if (step.type() != CrawlStepType.REQUEST) {
                    return true;
                }
            }
        }
        return automation.requiresBrowser();
    }

    public record RateLimit(int requestsPerMinute, int burst) {
        public static RateLimit of(int requestsPerMinute, int burst) {
            return new RateLimit(Math.max(0, requestsPerMinute), Math.max(1, burst));
        }

        public static RateLimit unlimited() {
            return new RateLimit(0, 1);
        }

        public boolean isLimited() {
            return requestsPerMinute > 0;
        }
    }
}
